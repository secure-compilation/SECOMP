(* *********************************************************************)
(*                                                                     *)
(*              The Compcert verified compiler                         *)
(*                                                                     *)
(*          Xavier Leroy, INRIA Paris-Rocquencourt                     *)
(*           Prashanth Mundkur, SRI International                      *)
(*                                                                     *)
(*  Copyright Institut National de Recherche en Informatique et en     *)
(*  Automatique.  All rights reserved.  This file is distributed       *)
(*  under the terms of the INRIA Non-Commercial License Agreement.     *)
(*                                                                     *)
(*  The contributions by Prashanth Mundkur are reused and adapted      *)
(*  under the terms of a Contributor License Agreement between         *)
(*  SRI International and INRIA.                                       *)
(*                                                                     *)
(* *********************************************************************)

(** Translation from Mach to RISC-V assembly language *)

Require Archi.
Require Import Coqlib Errors.
Require Import Zwf.
Require Import CapAST Integers Floats CapMemdata CapGlobalenvs.
Require Import Op Locations Mach Asm Conventions.

Local Open Scope string_scope.
Local Open Scope error_monad_scope.


(** each identifier is associated with an environment offset for the compartment under compilation *)
Parameter find_symbol_offset: ident -> option ptrofs.

Record asm_code: Type := mkAsmCode {
  ac_nextlabel: positive;
  ac_code: code;
  ac_call_site_count: ptrofs;                          
}.

Definition cons_asm_code (i: instruction) (c: asm_code) : asm_code :=
  mkAsmCode c.(ac_nextlabel) (i :: c.(ac_code)) c.(ac_call_site_count).

Definition app_asm_code (i: list instruction) (c: asm_code) : asm_code :=
  mkAsmCode c.(ac_nextlabel) (app i c.(ac_code)) c.(ac_call_site_count).

Infix ">>" := cons_asm_code (at level 60, right associativity).
Infix "++" := app_asm_code (right associativity, at level 60).

Definition incr_label (c : asm_code) : asm_code :=
  mkAsmCode (c.(ac_nextlabel) + 1) c.(ac_code) c.(ac_call_site_count).

Definition incr_callsite (c: asm_code) : asm_code :=
  mkAsmCode c.(ac_nextlabel) c.(ac_code) (Ptrofs.add c.(ac_call_site_count) Ptrofs.one).

(** The code generation functions take advantage of several
  characteristics of the [Mach] code generated by earlier passes of the
  compiler, mostly that argument and result registers are of the correct
  types.  These properties are true by construction, but it's easier to
  recheck them during code generation and fail if they do not hold. *)

(** Extracting integer or float registers. *)

Definition ireg_of (r: mreg) : res ireg :=
  match preg_of r with IR mr => OK mr | _ => Error(msg "Asmgen.ireg_of") end.

Definition freg_of (r: mreg) : res freg :=
  match preg_of r with FR mr => OK mr | _ => Error(msg "Asmgen.freg_of") end.

(** Decomposition of 32-bit integer constants.  They are split into either
  small signed immediates that fit in 12-bits, or, if they do not fit,
  into a (20-bit hi, 12-bit lo) pair where lo is sign-extended. *)

Inductive immed32 : Type :=
  | Imm32_single (imm: int)
  | Imm32_pair   (hi: int) (lo: int).

Definition make_immed32 (val: int) :=
  let lo := Int.sign_ext 12 val in
  if Int.eq val lo
  then Imm32_single val
  else Imm32_pair (Int.shru (Int.sub val lo) (Int.repr 12)) lo.
(*
  let discr := Int.shr val (Int.repr 11) in
  let hi    := Int.shru val (Int.repr 12) in
  if Int.eq discr Int.zero || Int.eq discr Int.mone
  then Imm32_single val
  else Imm32_pair (Int.add hi (Int.and discr Int.one)) (Int.sign_ext 12 val).
*)

(** Likewise, for 64-bit integer constants. *)

Inductive immed64 : Type :=
  | Imm64_single (imm: int64)
  | Imm64_pair   (hi: int64) (lo: int64)
  | Imm64_large  (imm: int64).

Definition make_immed64 (val: int64) :=
  let lo := Int64.sign_ext 12 val in
  if Int64.eq val lo then Imm64_single lo else
  let hi := Int64.zero_ext 20 (Int64.shru (Int64.sub val lo) (Int64.repr 12)) in
  if Int64.eq val (Int64.add (Int64.sign_ext 32 (Int64.shl hi (Int64.repr 12))) lo)
  then Imm64_pair hi lo
  else Imm64_large val.

(** Smart constructors for arithmetic operations involving
  a 32-bit or 64-bit integer constant.  Depending on whether the
  constant fits in 12 bits or not, one or several instructions
  are generated as required to perform the operation
  and prepended to the given instruction sequence [k]. *)

Definition load_hilo32_instr (r: ireg) (hi lo: int) :=
  if Int.eq lo Int.zero then Pluiw r hi :: nil
  else Pluiw r hi :: Paddiw r r lo :: nil.
Definition load_hilo32 (r: ireg) (hi lo: int) (k : asm_code) :=
  load_hilo32_instr r hi lo ++ k.
  
Definition loadimm32 (r: ireg) (n: int) (k: asm_code) :=
  match make_immed32 n with
  | Imm32_single imm => Paddiw r X0 imm >> k
  | Imm32_pair hi lo => load_hilo32 r hi lo k
  end.

Definition opimm32 (op: ireg -> ireg0 -> ireg0 -> instruction)
                   (opimm: ireg -> ireg0 -> int -> instruction)
                   (rd rs: ireg) (n: int) (k: asm_code) :=
  match make_immed32 n with
  | Imm32_single imm => opimm rd rs imm >> k
  | Imm32_pair hi lo => load_hilo32 X31 hi lo (op rd rs X31 >> k)
  end.

Definition opimm32r (op: ireg -> ireg0 -> ireg0 -> instruction)
                   (rd rs: ireg) (n: int) (k: asm_code) :=
  match make_immed32 n with
  | Imm32_single imm => Pluiw X31 imm >> op rd rs X31 >> k
  | Imm32_pair hi lo => load_hilo32 X31 hi lo (op rd rs X31 >> k)
  end.

Definition addimm32 := opimm32 Paddw Paddiw.
Definition subimm32 := opimm32r Psubw.
Definition andimm32 := opimm32 Pandw Pandiw.
Definition orimm32  := opimm32 Porw  Poriw.
Definition xorimm32 := opimm32 Pxorw Pxoriw.
Definition sltimm32 := opimm32 Psltw Psltiw.
Definition sltuimm32 := opimm32 Psltuw Psltiuw.
Definition leaimm32 := opimm32 PCiaddr_w PCiaddr_iw.
(* TODO: add an address increment for 32 and 64 bits, distinguish by requiring an int or long respectively *)

Definition load_hilo64_instr (r: ireg) (hi lo: int64) :=
  if Int64.eq lo Int64.zero then Pluil r hi :: nil
  else Pluil r hi :: Paddil r r lo :: nil.
Definition load_hilo64 (r: ireg) (hi lo: int64) k :=
  load_hilo64_instr r hi lo ++ k.

Definition loadimm64 (r: ireg) (n: int64) (k: asm_code) :=
  match make_immed64 n with
  | Imm64_single imm => Paddil r X0 imm >> k
  | Imm64_pair hi lo => load_hilo64 r hi lo k
  | Imm64_large imm  => Ploadli r imm >> k
  end.

Definition opimm64 (op: ireg -> ireg0 -> ireg0 -> instruction)
                   (opimm: ireg -> ireg0 -> int64 -> instruction)
                   (rd rs: ireg) (n: int64) (k: asm_code) :=
  match make_immed64 n with
  | Imm64_single imm => opimm rd rs imm >> k
  | Imm64_pair hi lo => load_hilo64 X31 hi lo (op rd rs X31 >> k)
  | Imm64_large imm  => Ploadli X31 imm >> op rd rs X31 >> k
  end.

Definition opimm64r (op: ireg -> ireg0 -> ireg0 -> instruction)
                   (rd rs: ireg) (n: int64) (k: asm_code) :=
  match make_immed64 n with
  | Imm64_single imm => Pluil X31 imm >> op rd rs X31 >> k
  | Imm64_pair hi lo => load_hilo64 X31 hi lo (op rd rs X31 >> k)
  | Imm64_large imm  => Ploadli X31 imm >> op rd rs X31 >> k
  end.

Definition addimm64 := opimm64 Paddl Paddil.
Definition subimm64 := opimm64r Psubl.
Definition andimm64 := opimm64 Pandl Pandil.
Definition orimm64  := opimm64 Porl  Poril.
Definition xorimm64 := opimm64 Pxorl  Pxoril.
Definition sltimm64 := opimm64 Psltl Psltil.
Definition sltuimm64 := opimm64 Psltul Psltiul.
Definition leaimm64 := opimm64 PCiaddr_l PCiaddr_il.

Definition addptrofs (rd rs: ireg) (n: ptrofs) (k: asm_code) :=
  if Ptrofs.eq_dec n Ptrofs.zero then
    Pmv rd rs >> k
  else
    if Archi.ptr64
    then addimm64 rd rs (Ptrofs.to_int64 n) k
    else addimm32 rd rs (Ptrofs.to_int n) k.

Definition subptrofs (rd rs: ireg) (n: ptrofs) (k: asm_code) :=
  if Ptrofs.eq_dec n Ptrofs.zero then
    Pmv rd rs >> k
  else
    if Archi.ptr64
    then subimm64 rd rs (Ptrofs.to_int64 n) k
    else subimm32 rd rs (Ptrofs.to_int n) k.

Definition addcapofs (rd rs: ireg) (n: ptrofs) (k: asm_code) :=
  if Ptrofs.eq_dec n Ptrofs.zero then
    Pmv rd rs >> k
  else
    if Archi.ptr64
    then leaimm64 rd rs (Ptrofs.to_int64 n) k
    else leaimm32 rd rs (Ptrofs.to_int n) k.

Definition opldc (dst: ireg) (cap: ireg) (ofs: offset) (h priv: bool) :=
  if Archi.ptr64 then PClcd dst cap ofs h priv
  else PClwc dst cap ofs h priv.

Definition opsc (cap: ireg) (dst: ireg) (ofs: offset) (h: bool) :=
  if Archi.ptr64 then PCscd cap dst ofs h
  else PCscw cap dst ofs h.

Definition opUsc (cap: ireg) (dst: ireg) (ptr: ireg) (ofs: offset) (h: bool) :=
  if Archi.ptr64 then PCUscd cap dst ptr ofs h
  else PCUscw cap dst ptr ofs h.
  
(** Translation of conditional branches. *)

Definition transl_cbranch_int32s (cmp: comparison) (r1 r2: ireg0) (lbl: label) :=
  match cmp with
  | Ceq => Pbeqw r1 r2 lbl
  | Cne => Pbnew r1 r2 lbl
  | Clt => Pbltw r1 r2 lbl
  | Cle => Pbgew r2 r1 lbl
  | Cgt => Pbltw r2 r1 lbl
  | Cge => Pbgew r1 r2 lbl
  end.

Definition transl_cbranch_int32u (cmp: comparison) (r1 r2: ireg0) (lbl: label) :=
  match cmp with
  | Ceq => Pbeqw  r1 r2 lbl
  | Cne => Pbnew  r1 r2 lbl
  | Clt => Pbltuw r1 r2 lbl
  | Cle => Pbgeuw r2 r1 lbl
  | Cgt => Pbltuw r2 r1 lbl
  | Cge => Pbgeuw r1 r2 lbl
  end.

Definition transl_cbranch_int64s (cmp: comparison) (r1 r2: ireg0) (lbl: label) :=
  match cmp with
  | Ceq => Pbeql r1 r2 lbl
  | Cne => Pbnel r1 r2 lbl
  | Clt => Pbltl r1 r2 lbl
  | Cle => Pbgel r2 r1 lbl
  | Cgt => Pbltl r2 r1 lbl
  | Cge => Pbgel r1 r2 lbl
  end.

Definition transl_cbranch_int64u (cmp: comparison) (r1 r2: ireg0) (lbl: label) :=
  match cmp with
  | Ceq => Pbeql  r1 r2 lbl
  | Cne => Pbnel  r1 r2 lbl
  | Clt => Pbltul r1 r2 lbl
  | Cle => Pbgeul r2 r1 lbl
  | Cgt => Pbltul r2 r1 lbl
  | Cge => Pbgeul r1 r2 lbl
  end.

Definition transl_cond_float (cmp: comparison) (rd: ireg) (fs1 fs2: freg) :=
  match cmp with
  | Ceq => (Pfeqd rd fs1 fs2, true)
  | Cne => (Pfeqd rd fs1 fs2, false)
  | Clt => (Pfltd rd fs1 fs2, true)
  | Cle => (Pfled rd fs1 fs2, true)
  | Cgt => (Pfltd rd fs2 fs1, true)
  | Cge => (Pfled rd fs2 fs1, true)
  end.
  
Definition transl_cond_single (cmp: comparison) (rd: ireg) (fs1 fs2: freg) :=
  match cmp with
  | Ceq => (Pfeqs rd fs1 fs2, true)
  | Cne => (Pfeqs rd fs1 fs2, false)
  | Clt => (Pflts rd fs1 fs2, true)
  | Cle => (Pfles rd fs1 fs2, true)
  | Cgt => (Pflts rd fs2 fs1, true)
  | Cge => (Pfles rd fs2 fs1, true)
  end.

Definition transl_cbranch
           (cond: condition) (args: list mreg) (lbl: label) (k: asm_code) :=
  match cond, args with
  | Ccomp c, (a1 :: a2 :: nil) =>
      do r1 <- (ireg_of a1); do r2 <- (ireg_of a2);
      OK (transl_cbranch_int32s c r1 r2 lbl >> k)
  | Ccompu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cbranch_int32u c r1 r2 lbl >> k)
  | Ccompimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (if Int.eq n Int.zero then
            transl_cbranch_int32s c r1 X0 lbl >> k
          else
            loadimm32 X31 n (transl_cbranch_int32s c r1 X31 lbl >> k))
  | Ccompuimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (if Int.eq n Int.zero then
            transl_cbranch_int32u c r1 X0 lbl >> k
          else
            loadimm32 X31 n (transl_cbranch_int32u c r1 X31 lbl >> k))
  | Ccompl c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cbranch_int64s c r1 r2 lbl >> k)
  | Ccomplu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cbranch_int64u c r1 r2 lbl >> k)
  | Ccomplimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (if Int64.eq n Int64.zero then
            transl_cbranch_int64s c r1 X0 lbl >> k
          else
            loadimm64 X31 n (transl_cbranch_int64s c r1 X31 lbl >> k))
  | Ccompluimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (if Int64.eq n Int64.zero then
            transl_cbranch_int64u c r1 X0 lbl >> k
          else
            loadimm64 X31 n (transl_cbranch_int64u c r1 X31 lbl >> k))
  | Ccompf c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_float c X31 r1 r2 in
      OK (insn >> (if normal then Pbnew X31 X0 lbl else Pbeqw X31 X0 lbl) >> k)
  | Cnotcompf c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_float c X31 r1 r2 in
      OK (insn >> (if normal then Pbeqw X31 X0 lbl else Pbnew X31 X0 lbl) >> k)
  | Ccompfs c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_single c X31 r1 r2 in
      OK (insn >> (if normal then Pbnew X31 X0 lbl else Pbeqw X31 X0 lbl) >> k)
  | Cnotcompfs c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_single c X31 r1 r2 in
      OK (insn >> (if normal then Pbeqw X31 X0 lbl else Pbnew X31 X0 lbl) >> k)
  | _, _ =>
      Error(msg "Asmgen.transl_cond_branch")
  end.

(** Translation of a condition operator.  The generated code sets the
  [rd] target register to 0 or 1 depending on the truth value of the
  condition. *)

Definition transl_cond_int32s (cmp: comparison) (rd: ireg) (r1 r2: ireg0) (k: asm_code) :=
  match cmp with
  | Ceq => Pseqw rd r1 r2 >> k
  | Cne => Psnew rd r1 r2 >> k
  | Clt => Psltw rd r1 r2 >> k
  | Cle => Psltw rd r2 r1 >> Pxoriw rd rd Int.one >> k
  | Cgt => Psltw rd r2 r1 >> k
  | Cge => Psltw rd r1 r2 >> Pxoriw rd rd Int.one >> k
  end.

Definition transl_cond_int32u (cmp: comparison) (rd: ireg) (r1 r2: ireg0) (k: asm_code) :=
  match cmp with
  | Ceq => Pseqw rd r1 r2 >> k
  | Cne => Psnew rd r1 r2 >> k
  | Clt => Psltuw rd r1 r2 >> k
  | Cle => Psltuw rd r2 r1 >> Pxoriw rd rd Int.one >> k
  | Cgt => Psltuw rd r2 r1 >> k
  | Cge => Psltuw rd r1 r2 >> Pxoriw rd rd Int.one >> k
  end.

Definition transl_cond_int64s (cmp: comparison) (rd: ireg) (r1 r2: ireg0) (k: asm_code) :=
  match cmp with
  | Ceq => Pseql rd r1 r2 >> k
  | Cne => Psnel rd r1 r2 >> k
  | Clt => Psltl rd r1 r2 >> k
  | Cle => Psltl rd r2 r1 >> Pxoriw rd rd Int.one >> k
  | Cgt => Psltl rd r2 r1 >> k
  | Cge => Psltl rd r1 r2 >> Pxoriw rd rd Int.one >> k
  end.

Definition transl_cond_int64u (cmp: comparison) (rd: ireg) (r1 r2: ireg0) (k: asm_code) :=
  match cmp with
  | Ceq => Pseql rd r1 r2 >> k
  | Cne => Psnel rd r1 r2 >> k
  | Clt => Psltul rd r1 r2 >> k
  | Cle => Psltul rd r2 r1 >> Pxoriw rd rd Int.one >> k
  | Cgt => Psltul rd r2 r1 >> k
  | Cge => Psltul rd r1 r2 >> Pxoriw rd rd Int.one >> k
  end.

Definition transl_condimm_int32s (cmp: comparison) (rd: ireg) (r1: ireg) (n: int) (k: asm_code) :=
  if Int.eq n Int.zero then transl_cond_int32s cmp rd r1 X0 k else
  match cmp with
  | Ceq | Cne => xorimm32 rd r1 n (transl_cond_int32s cmp rd rd X0 k)
  | Clt => sltimm32 rd r1 n k
  | Cle => if Int.eq n (Int.repr Int.max_signed)
           then loadimm32 rd Int.one k
           else sltimm32 rd r1 (Int.add n Int.one) k
  | _   => loadimm32 X31 n (transl_cond_int32s cmp rd r1 X31 k)
  end.

Definition transl_condimm_int32u (cmp: comparison) (rd: ireg) (r1: ireg) (n: int) (k: asm_code) :=
  if Int.eq n Int.zero then transl_cond_int32u cmp rd r1 X0 k else
  match cmp with
  | Clt => sltuimm32 rd r1 n k
  | _   => loadimm32 X31 n (transl_cond_int32u cmp rd r1 X31 k)
  end.

Definition transl_condimm_int64s (cmp: comparison) (rd: ireg) (r1: ireg) (n: int64) (k: asm_code) :=
  if Int64.eq n Int64.zero then transl_cond_int64s cmp rd r1 X0 k else
  match cmp with
  | Ceq | Cne => xorimm64 rd r1 n (transl_cond_int64s cmp rd rd X0 k)
  | Clt => sltimm64 rd r1 n k
  | Cle => if Int64.eq n (Int64.repr Int64.max_signed)
           then loadimm32 rd Int.one k
           else sltimm64 rd r1 (Int64.add n Int64.one) k
  | _   => loadimm64 X31 n (transl_cond_int64s cmp rd r1 X31 k)
  end.

Definition transl_condimm_int64u (cmp: comparison) (rd: ireg) (r1: ireg) (n: int64) (k: asm_code) :=
  if Int64.eq n Int64.zero then transl_cond_int64u cmp rd r1 X0 k else
  match cmp with
  | Clt => sltuimm64 rd r1 n k
  | _   => loadimm64 X31 n (transl_cond_int64u cmp rd r1 X31 k)
  end.

Definition transl_cond_op
           (cond: condition) (rd: ireg) (args: list mreg) (k: asm_code) :=
  match cond, args with
  | Ccomp c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cond_int32s c rd r1 r2 k)
  | Ccompu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cond_int32u c rd r1 r2 k)
  | Ccompimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_condimm_int32s c rd r1 n k)
  | Ccompuimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_condimm_int32u c rd r1 n k)
  | Ccompl c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cond_int64s c rd r1 r2 k)
  | Ccomplu c, a1 :: a2 :: nil =>
      do r1 <- ireg_of a1; do r2 <- ireg_of a2;
      OK (transl_cond_int64u c rd r1 r2 k)
  | Ccomplimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_condimm_int64s c rd r1 n k)
  | Ccompluimm c n, a1 :: nil =>
      do r1 <- ireg_of a1;
      OK (transl_condimm_int64u c rd r1 n k)
  | Ccompf c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_float c rd r1 r2 in
      OK (insn >> if normal then k else Pxoriw rd rd Int.one >> k)
  | Cnotcompf c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_float c rd r1 r2 in
      OK (insn >> if normal then Pxoriw rd rd Int.one >> k else k)
  | Ccompfs c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_single c rd r1 r2 in
      OK (insn >> if normal then k else Pxoriw rd rd Int.one >> k)
  | Cnotcompfs c, f1 :: f2 :: nil =>
      do r1 <- freg_of f1; do r2 <- freg_of f2;
      let (insn, normal) := transl_cond_single c rd r1 r2 in
      OK (insn >> if normal then Pxoriw rd rd Int.one >> k else k)
  | _, _ =>
      Error(msg "Asmgen.transl_cond_op")
  end.

(** macro for loading a symbol from the environment. Should return the
capability pointing to a symbol, and offset it by ofs *)
Definition load_environment_offset (rs: ireg) (ofs: ptrofs) (k: asm_code) :=
  Pmv X31 PCcap >>
  opldc rs X31 (Ofsimm Ptrofs.zero) true false >>
  addcapofs rs rs ofs
  (opldc rs rs (Ofsimm Ptrofs.zero) true false >> k).

(** the following variant is for offsets of 12 bits or less *)
Definition load_environment_offset_small (rs: ireg) (ofs: ptrofs) :=
  Pmv X31 PCcap ::
  opldc X31 X31 (Ofsimm Ptrofs.zero) true false ::
  opldc rs X31 (Ofsimm ofs) true false :: nil.

Definition load_symbol (rs: ireg) (s: ident) (ofs: ptrofs) (k: asm_code) :=
  match find_symbol_offset s with
  | Some off =>
      OK (load_environment_offset rs off (addcapofs rs rs ofs k))
  | None => Error(msg "Asmgen.env_error")
  end.

(** Translation of the arithmetic operation [r <- op(args)].
  The corresponding instructions are prepended to [k]. *)

Definition transl_op
              (op: operation) (args: list mreg) (res: mreg) (k: asm_code) :=
  match op, args with
  | Omove, a1 :: nil =>
      match preg_of res, preg_of a1 with
      | IR r, IR a => OK (Pmv r a >> k)
      | FR r, FR a => OK (Pfmv r a >> k)
      |  _  ,  _   => Error(msg "Asmgen.Omove")
      end
  | Ointconst n, nil =>
      do rd <- ireg_of res;
      OK (loadimm32 rd n k)
  | Olongconst n, nil =>
      do rd <- ireg_of res;
      OK (loadimm64 rd n k)
  | Ofloatconst f, nil =>
      do rd <- freg_of res;
      OK (if Float.eq_dec f Float.zero
          then Pfcvtdw rd X0 >> k
          else Ploadfi rd f >> k)
  | Osingleconst f, nil =>
      do rd <- freg_of res;
      OK (if Float32.eq_dec f Float32.zero
          then Pfcvtsw rd X0 >> k
          else Ploadsi rd f >> k)
  | Oaddrsymbol s ofs, nil =>
      do rd <- ireg_of res;
      (load_symbol rd s ofs k)
  | Oaddrstack n, nil =>
      (* do rd <- ireg_of res; *)
      (* OK (addptrofs rd SPC n k) *)
      do rd <- ireg_of res;
      OK (PCgl_s X31 SPC >> subptrofs rd X31 n k)
  | Ocast8signed, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Pslliw rd rs (Int.repr 24) >> Psraiw rd rd (Int.repr 24) >> k)
  | Ocast16signed, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Pslliw rd rs (Int.repr 16) >> Psraiw rd rd (Int.repr 16) >> k)
  | Oadd, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Paddw rd rs1 rs2 >> k)
  | Oaddimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (addimm32 rd rs n k)
  | Oneg, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (Psubw rd X0 rs >> k)
  | Osub, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psubw rd rs1 rs2 >> k)
  | Omul, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulw rd rs1 rs2 >> k)
  | Omulhs, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulhw rd rs1 rs2 >> k)
  | Omulhu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulhuw rd rs1 rs2 >> k)
  | Odiv, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pdivw rd rs1 rs2 >> k)
  | Odivu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pdivuw rd rs1 rs2 >> k)
  | Omod, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Premw rd rs1 rs2 >> k)
  | Omodu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Premuw rd rs1 rs2 >> k)
  | Oand, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pandw rd rs1 rs2 >> k)
  | Oandimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (andimm32 rd rs n k)
  | Oor, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Porw rd rs1 rs2 >> k)
  | Oorimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (orimm32 rd rs n k)
  | Oxor, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pxorw rd rs1 rs2 >> k)
  | Oxorimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (xorimm32 rd rs n k)
  | Oshl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psllw rd rs1 rs2 >> k)
  | Oshlimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Pslliw rd rs n >> k)
  | Oshr, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psraw rd rs1 rs2 >> k)
  | Oshrimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psraiw rd rs n >> k)
  | Oshru, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psrlw rd rs1 rs2 >> k)
  | Oshruimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psrliw rd rs n >> k)
  | Oshrximm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (if Int.eq n Int.zero then Pmv rd rs >> k else
          Psraiw X31 rs (Int.repr 31) >>
          Psrliw X31 X31 (Int.sub Int.iwordsize n) >>
          Paddw X31 rs X31 >>
          Psraiw rd X31 n >> k)  

  (* [Omakelong], [Ohighlong]  should not occur *)
  | Olowlong, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Pcvtl2w rd rs >> k)  
  | Ocast32signed, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      assertion (ireg_eq rd rs);
      OK (Pcvtw2l rd >> k)
  | Ocast32unsigned, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      assertion (ireg_eq rd rs);
      OK (Pcvtw2l rd >> Psllil rd rd (Int.repr 32) >> Psrlil rd rd (Int.repr 32) >> k)
  | Oaddl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Paddl rd rs1 rs2 >> k)
  | Oaddlimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (addimm64 rd rs n k)
  | Onegl, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (Psubl rd X0 rs >> k)
  | Osubl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psubl rd rs1 rs2 >> k)
  | Omull, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmull rd rs1 rs2 >> k)
  | Omullhs, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulhl rd rs1 rs2 >> k)
  | Omullhu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pmulhul rd rs1 rs2 >> k)
  | Odivl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pdivl rd rs1 rs2 >> k)
  | Odivlu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pdivul rd rs1 rs2 >> k)
  | Omodl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Preml rd rs1 rs2 >> k)
  | Omodlu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Premul rd rs1 rs2 >> k)
  | Oandl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pandl rd rs1 rs2 >> k)
  | Oandlimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (andimm64 rd rs n k)
  | Oorl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Porl rd rs1 rs2 >> k)
  | Oorlimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (orimm64 rd rs n k)
  | Oxorl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pxorl rd rs1 rs2 >> k)
  | Oxorlimm n, a1 :: nil =>
      do rd  <- ireg_of res; do rs <- ireg_of a1;
      OK (xorimm64 rd rs n k)
  | Oshll, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Pslll rd rs1 rs2 >> k)
  | Oshllimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psllil rd rs n >> k)
  | Oshrl, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psral rd rs1 rs2 >> k)
  | Oshrlimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psrail rd rs n >> k)
  | Oshrlu, a1 :: a2 :: nil =>
      do rd <- ireg_of res; do rs1 <- ireg_of a1; do rs2 <- ireg_of a2;
      OK (Psrll rd rs1 rs2 >> k)
  | Oshrluimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (Psrlil rd rs n >> k)
  | Oshrxlimm n, a1 :: nil =>
      do rd <- ireg_of res; do rs <- ireg_of a1;
      OK (if Int.eq n Int.zero then Pmv rd rs >> k else
          Psrail X31 rs (Int.repr 63) >>
          Psrlil X31 X31 (Int.sub Int64.iwordsize' n) >>
          Paddl X31 rs X31 >>
          Psrail rd X31 n >> k)  

  | Onegf, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfnegd rd rs >> k)
  | Oabsf, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfabsd rd rs >> k)
  | Oaddf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfaddd rd rs1 rs2 >> k)
  | Osubf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfsubd rd rs1 rs2 >> k)
  | Omulf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfmuld rd rs1 rs2 >> k)
  | Odivf, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfdivd rd rs1 rs2 >> k)

  | Onegfs, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfnegs rd rs >> k)
  | Oabsfs, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfabss rd rs >> k)
  | Oaddfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfadds rd rs1 rs2 >> k)
  | Osubfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfsubs rd rs1 rs2 >> k)
  | Omulfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfmuls rd rs1 rs2 >> k)
  | Odivfs, a1 :: a2 :: nil =>
      do rd <- freg_of res; do rs1 <- freg_of a1; do rs2 <- freg_of a2;
      OK (Pfdivs rd rs1 rs2 >> k)

  | Osingleoffloat, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfcvtsd rd rs >> k)
  | Ofloatofsingle, a1 :: nil =>
      do rd <- freg_of res; do rs <- freg_of a1;
      OK (Pfcvtds rd rs >> k)

  | Ointoffloat, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtwd rd rs >> k)
  | Ointuoffloat, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtwud rd rs >> k)
  | Ofloatofint, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtdw rd rs >> k)
  | Ofloatofintu, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtdwu rd rs >> k)
  | Ointofsingle, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtws rd rs >> k)
  | Ointuofsingle, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtwus rd rs >> k)
  | Osingleofint, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtsw rd rs >> k)
  | Osingleofintu, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtswu rd rs >> k)

  | Olongoffloat, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtld rd rs >> k)
  | Olonguoffloat, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtlud rd rs >> k)
  | Ofloatoflong, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtdl rd rs >> k)
  | Ofloatoflongu, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtdlu rd rs >> k)
  | Olongofsingle, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtls rd rs >> k)
  | Olonguofsingle, a1 :: nil =>
      do rd <- ireg_of res; do rs <- freg_of a1;
      OK (Pfcvtlus rd rs >> k)
  | Osingleoflong, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtsl rd rs >> k)
  | Osingleoflongu, a1 :: nil =>
      do rd <- freg_of res; do rs <- ireg_of a1;
      OK (Pfcvtslu rd rs >> k)

  | Ocmp cmp, _ =>
      do rd <- ireg_of res;
      transl_cond_op cmp rd args k

  | _, _ =>
      Error(msg "Asmgen.transl_op")
  end.

(** Accessing data in the stack frame. *)

Definition indexed_memory_access_branch
           (instrs_dir: list instruction)
           (instrs_def: list instruction)
           (instrs_uni: list instruction)
           (base: ireg) (k: asm_code) :=
  let lbl_def := ac_nextlabel k in
  let lbl_uni := (ac_nextlabel k + 1)%positive in
  let lbl_cont := (ac_nextlabel k + 2)%positive in
  let k' := incr_label (incr_label (incr_label k)) in
  Pptrbr base lbl_def lbl_uni >>
  instrs_dir ++
  Pj_l lbl_cont >>
  Plabel lbl_def >>
  instrs_def ++
  Pj_l lbl_cont >>
  Plabel lbl_uni >>
  instrs_uni ++
  Plabel lbl_cont >> k'.

(** Memory access for capabilities. [base] contains a capability,
    and [mk_instr_dir] is the instruction for direct loads *)
Definition indexed_memory_access_direct
           (mk_instr_dir: ireg -> offset -> instruction)
           (base: ireg) (ofs: ptrofs) : list instruction :=
  if Archi.ptr64 then
    match make_immed64 (Ptrofs.to_int64 ofs) with
    | Imm64_single imm =>
        mk_instr_dir base (Ofsimm (Ptrofs.of_int64 imm)) :: nil
    | Imm64_pair hi lo =>
        Pluil X31 hi :: PCiaddr_l X31 base X31 :: mk_instr_dir X31 (Ofsimm (Ptrofs.of_int64 lo)) :: nil
    | Imm64_large imm =>
        Ploadli X31 imm :: PCiaddr_l X31 base X31 :: mk_instr_dir X31 (Ofsimm Ptrofs.zero) :: nil
    end
  else
    match make_immed32 (Ptrofs.to_int ofs) with
    | Imm32_single imm =>
        mk_instr_dir base (Ofsimm (Ptrofs.of_int imm)) :: nil
    | Imm32_pair hi lo =>
        Pluiw X31 hi :: PCiaddr_w X31 base X31 :: mk_instr_dir X31 (Ofsimm (Ptrofs.of_int lo)) :: nil
    end.

(** Memory access for the heap. [base] contains a heap pointer, and
    [mk_instr_def] is the instruction for default loads through the
    DDC *)
Definition indexed_memory_access_heap
           (mk_instr_def: ireg -> offset -> instruction)
           (base: ireg) (ofs: ptrofs) : list instruction :=
  if Archi.ptr64 then
    match make_immed64 (Ptrofs.to_int64 ofs) with
    | Imm64_single imm =>
        mk_instr_def base (Ofsimm (Ptrofs.of_int64 imm)) :: nil
    | Imm64_pair hi lo =>
        Pluil X31 hi :: Paddl X31 base X31 :: mk_instr_def X31 (Ofsimm (Ptrofs.of_int64 lo)) :: nil
    | Imm64_large imm =>
        Ploadli X31 imm :: Paddl X31 base X31 :: mk_instr_def X31 (Ofsimm Ptrofs.zero) :: nil
    end
  else
    match make_immed32 (Ptrofs.to_int ofs) with
    | Imm32_single imm =>
        mk_instr_def base (Ofsimm (Ptrofs.of_int imm)) :: nil
    | Imm32_pair hi lo =>
        Pluiw X31 hi :: Paddw X31 base X31 :: mk_instr_def X31 (Ofsimm (Ptrofs.of_int lo)) :: nil
    end.

(** Memory access for the stack. [base] contains a stack pointer, and
    [mk_instr_dir] is the instruction for uninitialized loads. In this
    version, [ofs] is interpreted as an additional offset from SP end *)
Definition indexed_memory_access_stack
           (mk_instr_uni: ireg -> ireg -> offset -> instruction)
           (base: ireg) (ofs: ptrofs) : list instruction :=
  if Archi.ptr64 then
    match make_immed64 (Ptrofs.to_int64 ofs) with
    | Imm64_single imm =>
        Paddil X31 base imm :: mk_instr_uni SPC X31 (Ofsimm Ptrofs.zero) :: nil
    | Imm64_pair hi lo =>
        Pluil X31 hi :: Paddl X31 base X31 :: Paddil X31 X31 lo :: mk_instr_uni SPC X31 (Ofsimm Ptrofs.zero) :: nil
    | Imm64_large imm =>
        Ploadli X31 imm :: Paddl X31 base X31 :: mk_instr_uni SPC X31 (Ofsimm Ptrofs.zero) :: nil
    end
  else
    match make_immed32 (Ptrofs.to_int ofs) with
    | Imm32_single imm =>
        Paddiw X31 base imm :: mk_instr_uni SPC X31 (Ofsimm Ptrofs.zero) :: nil
    | Imm32_pair hi lo =>
        Pluiw X31 hi :: Paddw X31 base X31 :: Paddiw X31 X31 lo :: mk_instr_uni SPC X31 (Ofsimm Ptrofs.zero) :: nil
    end.

(** Memory access for the stack. [mk_instr_dir] is the instruction for
    uninitialized loads. In this version, [ofs] is interpreted as the
    offset from SP base *)
Definition indexed_memory_access_stack_ofs
           (mk_instr_uni: ireg -> ireg -> offset -> instruction)
           (ofs: ptrofs) : list instruction :=
  if Archi.ptr64 then
    match make_immed64 (Ptrofs.to_int64 ofs) with
    | Imm64_single imm =>
        PCgl_s X31 SPC :: mk_instr_uni SPC X31 (Ofsimm (Ptrofs.of_int64 imm)) :: nil
    | Imm64_pair hi lo =>
        PCgl_s X32 SPC :: Pluil X31 hi :: Psubl X31 X32 X31 :: mk_instr_uni SPC X31 (Ofsimm (Ptrofs.of_int64 lo)) :: nil
    | Imm64_large imm =>
        PCgl_s X32 SPC :: Ploadli X31 imm :: Psubl X31 X32 X31 :: mk_instr_uni SPC X31 (Ofsimm Ptrofs.zero) :: nil
    end
  else
    match make_immed32 (Ptrofs.to_int ofs) with
    | Imm32_single imm =>
        PCgl_s X31 SPC :: mk_instr_uni SPC X31 (Ofsimm (Ptrofs.of_int imm)) :: nil
    | Imm32_pair hi lo =>
        PCgl_s X32 SPC :: Pluiw X31 hi :: Psubw X31 X32 X31 :: mk_instr_uni SPC X31 (Ofsimm (Ptrofs.of_int lo)) :: nil
    end.


Definition indexed_memory_access
           (mk_instr_dir: ireg -> offset -> instruction)
           (mk_instr_def: ireg -> offset -> instruction)
           (mk_instr_uni: ireg -> ireg -> offset -> instruction)
           (base: ireg) (ofs: ptrofs) (k: asm_code) :=
  indexed_memory_access_branch
    (indexed_memory_access_direct mk_instr_dir base ofs)
    (indexed_memory_access_heap mk_instr_def base ofs)
    (indexed_memory_access_stack mk_instr_uni base ofs)
    base k.
      
(* Definition indexed_memory_access *)
(*         (mk_instr: ireg -> offset -> instruction) *)
(*         (base: ireg) (ofs: ptrofs) (k: asm_code) := *)
(*   if Archi.ptr64 then *)
(*     match make_immed64 (Ptrofs.to_int64 ofs) with *)
(*     | Imm64_single imm => *)
(*         mk_instr base (Ofsimm (Ptrofs.of_int64 imm)) >> k *)
(*     | Imm64_pair hi lo => *)
(*         Pluil X31 hi >> Paddl X31 base X31 >> mk_instr X31 (Ofsimm (Ptrofs.of_int64 lo)) >> k *)
(*     | Imm64_large imm => *)
(*         Ploadli X31 imm >> Paddl X31 base X31 >> mk_instr X31 (Ofsimm Ptrofs.zero) >> k *)
(*     end *)
(*   else *)
(*     match make_immed32 (Ptrofs.to_int ofs) with *)
(*     | Imm32_single imm => *)
(*         mk_instr base (Ofsimm (Ptrofs.of_int imm)) >> k *)
(*     | Imm32_pair hi lo => *)
(*         Pluiw X31 hi >> Paddw X31 base X31 >> mk_instr X31 (Ofsimm (Ptrofs.of_int lo)) >> k *)
(*     end. *)

(* The [priv] parameter is used to determine is this is a parameter load or not *)
Definition loadind (base: ireg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: asm_code) (is_heap: bool) (priv: bool) :=
  match ty, preg_of dst with
  | Tint,    IR rd => OK (indexed_memory_access (fun i o => PClw rd i o is_heap priv)
                                               (fun i o => Plw rd i o priv)
                                               (fun i r o => PCUlw rd i r o is_heap priv) base ofs k)
  | Tlong,   IR rd => OK (indexed_memory_access (fun i o => PCld rd i o is_heap priv)
                                               (fun i o => Pld rd i o priv)
                                               (fun i r o => PCUld rd i r o is_heap priv) base ofs k)
  | Tsingle, FR rd => OK (indexed_memory_access (fun i o => PCfls rd i o is_heap priv)
                                               (fun i o => Pfls rd i o priv)
                                               (fun i r o => PCUfls rd i r o is_heap priv) base ofs k)
  | Tfloat,  FR rd => OK (indexed_memory_access (fun i o => PCfld rd i o is_heap priv)
                                               (fun i o => Pfld rd i o priv)
                                               (fun i r o => PCUfld rd i r o is_heap priv) base ofs k)
  | Tany32,  IR rd => OK (indexed_memory_access (fun i o => PClw_a rd i o is_heap priv)
                                               (fun i o => Plw_a rd i o priv)
                                               (fun i r o => PCUlw_a rd i r o is_heap priv) base ofs k)
  | Tany64,  IR rd => OK (indexed_memory_access (fun i o => PCld_a rd i o is_heap priv)
                                               (fun i o => Pld_a rd i o priv)
                                               (fun i r o => PCUld_a rd i r o is_heap priv) base ofs k)
  | Tany64,  FR rd => OK (indexed_memory_access (fun i o => PCfld_a rd i o is_heap priv)
                                               (fun i o => Pfld_a rd i o priv)
                                               (fun i r o => PCUfld_a rd i r o is_heap priv) base ofs k)
  | _, _           => Error (msg "Asmgen.loadind")
  end.

Definition storeind (src: mreg) (base: ireg) (ofs: ptrofs) (ty: typ) (k: asm_code) (is_heap: bool) :=
  match ty, preg_of src with
  | Tint,    IR rd => OK (indexed_memory_access (fun i o => PCsw rd i o is_heap)
                                               (Psw rd)
                                               (fun i r o => PCUsw rd i r o is_heap) base ofs k)
  | Tlong,   IR rd => OK (indexed_memory_access (fun i o => PCsd rd i o is_heap)
                                               (Psd rd)
                                               (fun i r o => PCUsd rd i r o is_heap) base ofs k)
  | Tsingle, FR rd => OK (indexed_memory_access (fun i o => PCfss rd i o is_heap)
                                               (Pfss rd)
                                               (fun i r o => PCUfss rd i r o is_heap) base ofs k)
  | Tfloat,  FR rd => OK (indexed_memory_access (fun i o => PCfsd rd i o is_heap)
                                               (Pfsd rd)
                                               (fun i r o => PCUfsd rd i r o is_heap) base ofs k)
  | Tany32,  IR rd => OK (indexed_memory_access (fun i o => PCsw_a rd i o is_heap)
                                               (Psw_a rd)
                                               (fun i r o => PCUsw_a rd i r o is_heap) base ofs k)
  | Tany64,  IR rd => OK (indexed_memory_access (fun i o => PCsd_a rd i o is_heap)
                                               (Psd_a rd)
                                               (fun i r o => PCUsd_a rd i r o is_heap) base ofs k)
  | Tany64,  FR rd => OK (indexed_memory_access (fun i o => PCfsd_a rd i o is_heap)
                                               (Pfsd_a rd)
                                               (fun i r o => PCUfsd_a rd i r o is_heap) base ofs k)
  | _, _           => Error (msg "Asmgen.storeind")
  end.

Definition loadind_ptr (base: ireg) (ofs: ptrofs) (dst: ireg) (k: asm_code) (is_heap: bool) (priv: bool):=
  indexed_memory_access
    (if Archi.ptr64 then fun i o => PCld dst i o is_heap priv else fun i o => PClw dst i o is_heap priv)
    (if Archi.ptr64 then fun i o => Pld dst i o priv else fun i o => Plw dst i o priv)
    (if Archi.ptr64 then fun i r o => PCUld dst i r o is_heap priv else fun i r o => PCUlw dst i r o is_heap priv)
    base ofs k.

Definition storeind_ptr (src: ireg) (base: ireg) (ofs: ptrofs) (k: asm_code) (is_heap: bool) :=
  indexed_memory_access
    (if Archi.ptr64 then fun i o => PCsd src i o is_heap else fun i o => PCsw src i o is_heap)
    (if Archi.ptr64 then Psd src else Psw src)
    (if Archi.ptr64 then fun i r o => PCUsd src i r o is_heap else fun i r o => PCUsw src i r o is_heap)
    base ofs k.

Definition loadind_ptr_stk (ofs: ptrofs) (dst: ireg) (k: asm_code) (priv: bool):=
  indexed_memory_access_stack_ofs (if Archi.ptr64 then fun i r o => PCUld dst i r o false priv
                                   else fun i r o => PCUlw dst i r o false priv) ofs ++ k.

Definition storeind_ptr_stk (src: ireg) (ofs: ptrofs) (k: asm_code) :=
  indexed_memory_access_stack_ofs (if Archi.ptr64 then fun i r o => PCUsd src i r o false
                                   else fun i r o => PCUsw src i r o false) ofs ++ k.

Definition loadind_direct (base: ireg) (ofs: ptrofs) (ty: typ) (dst: mreg) (k: asm_code) (is_heap: bool) (priv: bool) :=
  match ty, preg_of dst with
  | Tint,    IR rd => OK (indexed_memory_access_direct (fun i o => PClw rd i o is_heap priv) base ofs ++ k)
  | Tlong,   IR rd => OK (indexed_memory_access_direct (fun i o => PCld rd i o is_heap priv) base ofs ++ k)
  | Tsingle, FR rd => OK (indexed_memory_access_direct (fun i o => PCfls rd i o is_heap priv) base ofs ++ k)
  | Tfloat,  FR rd => OK (indexed_memory_access_direct (fun i o => PCfld rd i o is_heap priv) base ofs ++ k)
  | Tany32,  IR rd => OK (indexed_memory_access_direct (fun i o => PClw_a rd i o is_heap priv) base ofs ++ k)
  | Tany64,  IR rd => OK (indexed_memory_access_direct (fun i o => PCld_a rd i o is_heap priv) base ofs ++ k)
  | Tany64,  FR rd => OK (indexed_memory_access_direct (fun i o => PCfld_a rd i o is_heap priv) base ofs ++ k)
  | _, _           => Error (msg "Asmgen.loadind")
  end.

Definition loadind_stack_ofs (ofs: ptrofs) (ty: typ) (dst: mreg) (k: asm_code) :=
  match ty, preg_of dst with
  | Tint,    IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUlw rd i r o false false) ofs ++ k)
  | Tlong,   IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUld rd i r o false false) ofs ++ k)
  | Tsingle, FR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUfls rd i r o false false) ofs ++ k)
  | Tfloat,  FR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUfld rd i r o false false) ofs ++ k)
  | Tany32,  IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUlw_a rd i r o false false) ofs ++ k)
  | Tany64,  IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUld_a rd i r o false false) ofs ++ k)
  | Tany64,  FR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUfld_a rd i r o false false) ofs ++ k)
  | _, _           => Error (msg "Asmgen.loadind")
  end.

Definition storeind_stack_ofs (src: mreg) (ofs: ptrofs) (ty: typ) (k: asm_code) :=
  match ty, preg_of src with
  | Tint,    IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUsw rd i r o false) ofs ++ k)
  | Tlong,   IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUsd rd i r o false) ofs ++ k)
  | Tsingle, FR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUfss rd i r o false) ofs ++ k)
  | Tfloat,  FR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUfsd rd i r o false) ofs ++ k)
  | Tany32,  IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUsw_a rd i r o false) ofs ++ k)
  | Tany64,  IR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUsd_a rd i r o false) ofs ++ k)
  | Tany64,  FR rd => OK (indexed_memory_access_stack_ofs (fun i r o => PCUfsd_a rd i r o false) ofs ++ k)
  | _, _           => Error (msg "Asmgen.storeind")
  end.


(** Translation of memory accesses: loads, and stores. *)

Definition transl_memory_access
     (mk_instr_dir: ireg -> offset -> instruction)
     (mk_instr_def: ireg -> offset -> instruction)
     (mk_instr_uni: ireg -> ireg -> offset -> instruction)
     (addr: addressing) (args: list mreg) (k: asm_code) :=
  match addr, args with
  | Aindexed ofs, a1 :: nil =>
      do rs <- ireg_of a1;
      OK (indexed_memory_access mk_instr_dir mk_instr_def mk_instr_uni rs ofs k)
  | Aglobal id ofs, nil =>
      load_symbol X31 id ofs (mk_instr_dir X31 (Ofslow id ofs) >> k) (* is offset added twice? *)
  | Ainstack ofs, nil =>
      OK (indexed_memory_access_stack_ofs mk_instr_uni ofs ++ k)
  | _, _ =>
      Error(msg "Asmgen.transl_memory_access")
  end.

Definition transl_load (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (dst: mreg) (is_heap: bool) (k: asm_code) :=
  match chunk with
  | Mint8signed =>
      do r <- ireg_of dst;
      transl_memory_access
        (fun i o => PClb r i o is_heap false)
        (fun i o => Plb r i o false)
        (fun r1 r2 o => PCUlb r r1 r2 o is_heap false)
        addr args k
  | Mint8unsigned =>
      do r <- ireg_of dst;
      transl_memory_access
        (fun i o => PClbu r i o is_heap false)
        (fun i o => Plbu r i o false)
        (fun r1 r2 o => PCUlbu r r1 r2 o is_heap false)
        addr args k
  | Mint16signed =>
      do r <- ireg_of dst;
      transl_memory_access
        (fun i o => PClh r i o is_heap false)
        (fun i o => Plh r i o false)
        (fun r1 r2 o => PCUlh r r1 r2 o is_heap false)
        addr args k
  | Mint16unsigned =>
      do r <- ireg_of dst;
      transl_memory_access
        (fun i o => PClhu r i o is_heap false)
        (fun i o => Plhu r i o false)
        (fun r1 r2 o => PCUlhu r r1 r2 o is_heap false)
        addr args k
  | Mint32 =>
      do r <- ireg_of dst;
      transl_memory_access
        (fun i o => PClw r i o is_heap false)
        (fun i o => Plw r i o false)
        (fun r1 r2 o => PCUlw r r1 r2 o is_heap false)
        addr args k
  | Mint64 =>
      do r <- ireg_of dst;
      transl_memory_access
        (fun i o => PCld r i o is_heap false)
        (fun i o => Pld r i o false)
        (fun r1 r2 o => PCUld r r1 r2 o is_heap false)
        addr args k
  | Mfloat32 =>
      do r <- freg_of dst;
      transl_memory_access
        (fun i o => PCfls r i o is_heap false)
        (fun i o => Pfls r i o false)
        (fun r1 r2 o => PCUfls r r1 r2 o is_heap false)
        addr args k
  | Mfloat64 =>
      do r <- freg_of dst;
      transl_memory_access
        (fun i o => PCfld r i o is_heap false)
        (fun i o => Pfld r i o false)
        (fun r1 r2 o => PCUfld r r1 r2 o is_heap false)
        addr args k
  | _ =>
      Error (msg "Asmgen.transl_load")
  end.

Definition transl_store (chunk: memory_chunk) (addr: addressing)
           (args: list mreg) (src: mreg) (is_heap: bool) (k: asm_code) :=
  match chunk with
  | Mint8signed | Mint8unsigned =>
      do r <- ireg_of src;
      transl_memory_access
        (fun i o => PCsb r i o is_heap)
        (Psb r)
        (fun r1 r2 o => PCUsb r r1 r2 o is_heap)
        addr args k
  | Mint16signed | Mint16unsigned =>
      do r <- ireg_of src;
      transl_memory_access
        (fun i o => PCsh r i o is_heap)
        (Psh r)
        (fun r1 r2 o => PCUsh r r1 r2 o is_heap)
        addr args k
  | Mint32 =>
      do r <- ireg_of src;
      transl_memory_access
        (fun i o => PCsw r i o is_heap)
        (Psw r)
        (fun r1 r2 o => PCUsw r r1 r2 o is_heap)
        addr args k
  | Mint64 =>
      do r <- ireg_of src;
      transl_memory_access
        (fun i o => PCsd r i o is_heap)
        (Psd r)
        (fun r1 r2 o => PCUsd r r1 r2 o is_heap)
        addr args k
  | Mfloat32 =>
      do r <- freg_of src;
      transl_memory_access
        (fun i o => PCfss r i o is_heap)
        (Pfss r)
        (fun r1 r2 o => PCUfss r r1 r2 o is_heap)
        addr args k
  | Mfloat64 =>
      do r <- freg_of src;
      transl_memory_access
        (fun i o => PCfsd r i o is_heap)
        (Pfsd r)
        (fun r1 r2 o => PCUfsd r r1 r2 o is_heap)
        addr args k
  | _ =>
      Error (msg "Asmgen.transl_store")
  end.


(** Entry wrapper *)

Fixpoint option_list_filter {A: Type} (l: list (option A)) : list A :=
  match l with
  | nil => nil
  | (Some a) :: l' => a :: option_list_filter l'
  | None :: l' => option_list_filter l'
  end.

Definition create_idxlist_int (regs: list ireg) : list Z :=
  option_list_filter (List.map (fun r => option_map Z.of_nat (find_index (ireg_eq r) int_regs)) regs).
Definition create_idxlist_float (regs: list freg) : list Z :=
  option_list_filter (List.map (fun r => option_map Z.of_nat (find_index (freg_eq r) float_regs)) regs).

Fixpoint get_iregs_from_loc (l: list loc) : (list ireg) :=
  match l with
  | nil => nil
  | S _ _ _ :: l' => get_iregs_from_loc l'
  | R r :: l' => match preg_of r with
             | IR mr => mr :: get_iregs_from_loc l'
             | _ => get_iregs_from_loc l'
             end
  end.
Fixpoint get_fregs_from_loc (l: list loc) : (list freg) :=
  match l with
  | nil => nil
  | S _ _ _ :: l' => get_fregs_from_loc l'
  | R r :: l' => match preg_of r with
             | FR mr => mr :: get_fregs_from_loc l'
             | _ => get_fregs_from_loc l'
             end
  end.

Fixpoint list_difference {A: Type} (adec: forall (a b : A), {a = b} + {a <> b}) (l1 l2 : list A) : list A :=
  List.filter (fun a => negb (in_dec adec a l2)) l1.

Definition int_iregs (rs: list ireg) : int := Int.repr (2 * (Zbits.powerserie (create_idxlist_int rs))).
Definition int_fregs (rs: list freg) : int := Int.repr (Zbits.powerserie (create_idxlist_float rs)).

Definition clear_regs_int (sig: signature) (extra: list ireg) :=
  let iregs_params := get_iregs_from_loc (regs_of_rpairs (loc_parameters sig)) in
  let iregs := list_difference ireg_eq int_regs (extra ++ iregs_params) in
  PCCclear (int_iregs iregs).
Definition clear_regs_float (sig: signature) :=
  let fregs_params := get_fregs_from_loc (regs_of_rpairs (loc_parameters sig)) in
  let fregs := list_difference freg_eq float_regs (fregs_params) in
  PCCclearf (int_fregs fregs).


Function store_zeros_routine (cap: ireg) (zero: ireg) (size: Z) {wf (Zwf 0) size} :=
  if zle size 0 then
    nil
  else
    PCUtoPtr_s X31 cap cap ::
    PCUsb zero cap X31 (Ofsimm Ptrofs.zero) false ::
    store_zeros_routine cap zero (size - 1).
Proof.
  intros. red. omega.
  apply Zwf_well_founded.
Qed.

(** @PRE: 
    - SPC contains the caller's unsealed stack pointer 
    - RAC contains an unsealed capability to the callee's next instruction
    - X3 contains the caller's seal key capability, pointing to the key of their choice
    - X30 contains the caller's parameter capability
    @USES:
    SPC, RAC, X3, X4, X5
    clears all integer registers expect SPC, RAC and X30
    @POST:
    - SPC contains a capability to the initialized callee stack frame
    - RAC contains the sealed return capability
    - X30 contains a RO Directed capability pointing to spilled parameters
*)
Definition make_entry_wrapper (sig: signature) (f: Mach.function) (next_label: label) :=
  let lbl1 := next_label in
  let lbl2 := (next_label + 1)%positive in
  let outgoing_size := Ptrofs.unsigned f.(fn_link_ofs) in
  let local_frame_size := f.(fn_stacksize) - Ptrofs.unsigned f.(fn_param_link_ofs) in
  
  (* SECURITY *)
  (* load return wrapper capability *)
  Pmv X31 PCcap ::
  opldc X31 X31 (Ofsimm Ptrofs.one) true false ::
  (* store given return cap into the return wrapper cap *)    
  opsc RAC X31 (Ofsimm Ptrofs.zero) true ::
  (* restrict PC to size 1 *)
  Pmv X31 PCcap ::
  PCsbase_iw X31 X31 (Int.repr (if Archi.ptr64 then 16 else 8)) ::
  Pmv PCcap X31 ::
  (* seal the stack pointer *)
  PCseal X4 SPC X3 ::
  (* seal the ret-wrapper cap *)
  PCseal RAC RAC X3 ::
  (* check that param cap is RO *)
  PCgp X31 X30 ::
  Paddiw X5 X0 (encode_perm_int OCapValues.RO) ::
  Pbeqw X5 X31 lbl1 ::
  Pfail ::
  Plabel lbl1 ::
  (* check that each parameter is non capability *)
  PCloadtag X31 X30 ::
  Pbeqw X31 X0 lbl2 ::
  Pfail ::
  Plabel lbl2 ::
  (* restrict the stack pointer *)
  PCUtoPtr_s X31 SPC SPC ::
  PCsbase SPC SPC X31 ::
  (* clear non parameter registers *)
  clear_regs_int sig (SPC :: RAC :: X30 :: X4 :: nil) ::
  (* clear_regs_float sig :: *)

  (* FUNCTIONALITY *)
  (* initialize the outgoing stack region *)
  Paddiw X5 X0 Int.zero ::
  store_zeros_routine SPC X5 outgoing_size ++
  (* store the old sealed sp *)
  PCUtoPtr_s X31 SPC SPC ::
  opUsc X4 SPC X31 (Ofsimm Ptrofs.zero) false ::
  opUsc RAC SPC X31 (Ofsimm Ptrofs.one) false ::
  opUsc X30 SPC X31 (Ofsimm (Ptrofs.repr 2)) false ::
  (* initialize remaining stack frame *)
  store_zeros_routine SPC X5 local_frame_size ++
  (* load the heap capability into DDC *)
  load_environment_offset_small X31 Ptrofs.zero ++
  Pmv DDcap X31 :: nil.

Definition fetch_callt (t: ireg + ident) (r: ireg) (k: asm_code) :=
  match t with
  | inl s => OK (Pmv r s >> k)
  | inr id => load_symbol r id Ptrofs.zero k
  end.

Definition ireg_of_inl {A: Type} (t: mreg + A) :=
  match t with
  | inl m => do r <- ireg_of m; OK (inl r)
  | inr a => OK (inr a)
  end.

(** The prologue fetches the function target, creates the seal
  capability to point to the next call_site. The call then
  jumps-and-link to the target *)
Definition make_call (sig: signature) (call_site: ptrofs) (t: ireg + ident) (f: Mach.function) (k: asm_code) :=
  let outgoing_size := f.(fn_link_ofs) in
  
  (* fetch function target *)
  fetch_callt t RAC
  (* fetch key seal capability and offset it to call_site *)
  (load_environment_offset_small X3 Ptrofs.one ++
  addcapofs X3 X3 call_site
  (* derive RO parameter capability *)
  (Pmv X30 SPC >>
  PCgb_s X31 X30 >>
  addptrofs X31 X31 outgoing_size
  (PCsaddr_w X30 X30 X31 >>
  PCpromote X30 X30 >>
  Paddiw X31 X0 (encode_perm_int OCapValues.RO) >>
  PCpermand X30 X30 X31 >>
  PCgb_s X31 X30 >>
  PCsaddr_w X30 X30 X31 >>
  (* jump and link to target *)
  Pjal_r RAC sig true >>

  (* UPON RETURN *)
  (* restore heap cap into DDC *)
  load_environment_offset_small X31 Ptrofs.zero ++ (Pmv DDcap X31 >> k)))).

(** Return wrapper *)

Fixpoint check_registers_loop (regs: list ireg) (dst: ireg) : list instruction :=
  match regs with
  | nil => nil
  | r :: regs' =>
      PCgg X31 r :: Pandw dst dst X31 :: check_registers_loop regs' dst
  end.
Definition check_registers (regs: list ireg) (dst: ireg) : list instruction :=
  Paddiw dst X0 (Int.one) :: check_registers_loop regs dst.

Definition check_registers_crash (regs: list ireg) (next_label: label) : list instruction :=
  check_registers regs X31 ++ (Pbnew X0 X31 next_label :: Pfail :: Plabel next_label :: nil).

(** The return wrapper is the same for all functions 
  @PRE: 
  - X31 contains the old stack pointer, now unsealed by invoke *)
Definition return_wrapper_code (next_label: label) :=
  (* move the old SP to SPC *)
  Pmv SPC X31 ::
  (* check that return value is not a capability *)
  check_registers_crash (X10 :: X11 :: nil) next_label ++
  (* load the return capability *)
  Pmv X31 PCcap ::
  opldc RAC X31 (Ofsimm Ptrofs.zero) true false ::
  (* clear the remaining registers (no need to clear float registers, as they cannot hold capabilities) *)
  PCCclear (int_iregs (list_difference ireg_eq int_regs (RAC :: SPC :: nil))) ::
  (* jmp to return capability *)
  Pj_r RAC ::
  nil.
  
(** Function epilogue *)
        
Definition make_epilogue (f: Mach.function) (k: asm_code) :=
  loadind_ptr_stk f.(fn_retaddr_ofs) RAC
       (loadind_ptr_stk f.(fn_link_ofs) SPC k false) false.

Definition make_return (k: asm_code) :=
  let next_label := k.(ac_nextlabel) in

  PCgs X31 RAC >>
  Pbeqw X31 X0 next_label >>
  Pj_r RAC >>
  Plabel next_label >>
  PCinvoke RAC SPC true >>
  incr_label k.
  
(* Definition make_epilogue (f: Mach.function) (k: asm_code) := *)
(*   loadind_ptr SP f.(fn_retaddr_ofs) RA *)
(*     (Pfreeframe f.(fn_stacksize) f.(fn_link_ofs) >> k) false. *)

(** Translation of a Mach instruction. *)

Definition transl_instr (f: Mach.function) (i: Mach.instruction)
                        (ep: bool) (k: asm_code) :=
  match i with
  | Mgetstack ofs ty dst =>
      loadind_stack_ofs ofs ty dst k
  | Msetstack src ofs ty =>
      storeind_stack_ofs src ofs ty k
  | Mgetparam ofs ty dst =>
      (* load via the frame pointer if it is valid *)
      do c <- loadind_direct X30 ofs ty dst k false true ;
      OK (if ep then c
                else loadind_ptr_stk f.(fn_link_ofs) X30 c true)
  | Mop op args res =>
      transl_op op args res k
  | Mload chunk addr args dst =>
      transl_load chunk addr args dst true k
  | Mstore chunk addr args src =>
      transl_store chunk addr args src true k
  | Mcall sig t =>
      do r1 <- ireg_of_inl t;
      make_call sig k.(ac_call_site_count) r1 f (incr_callsite k)
  | Mtailcall sig (inl r) =>
      do r1 <- ireg_of r;
      OK (make_epilogue f (Pj_r r1 >> k))
  | Mtailcall sig (inr symb) =>
      load_symbol X30 symb Ptrofs.zero (make_epilogue f (Pj_r X30 >> k))
  | Mbuiltin ef args res =>
      OK (Pbuiltin ef (List.map (map_builtin_arg preg_of) args) (map_builtin_res preg_of res) >> k)
  | Mlabel lbl =>
      OK (Plabel lbl >> k)
  | Mgoto lbl =>
      OK (Pj_l lbl >> k)
  | Mcond cond args lbl =>
      transl_cbranch cond args lbl k
  | Mjumptable arg tbl =>
      do r <- ireg_of arg;
      OK (Pbtbl r tbl >> k)
  | Mreturn =>
      OK (make_epilogue f (make_return k))
  end.

(** Translation of a code sequence *)

Definition it1_is_parent (before: bool) (i: Mach.instruction) : bool :=
  match i with
  | Msetstack src ofs ty => before
  | Mgetparam ofs ty dst => negb (mreg_eq dst R30)
  | Mop op args res => before && negb (mreg_eq res R30)
  | _ => false
  end.

(** This is the naive definition that we no longer use because it
  is not tail-recursive.  It is kept as specification. *)

Fixpoint

Fixpoint transl_code (f: Mach.function) (il: list Mach.instruction) (it1p: bool) : asm_code :=
  match il with
  | nil => OK nil
  | i1 :: il' =>
      do k <- transl_code f il' (it1_is_parent it1p i1);
      transl_instr f i1 it1p k
  end.

(** This is an equivalent definition in continuation-passing style
  that runs in constant stack space. *)

Fixpoint transl_code_rec (f: Mach.function) (il: list Mach.instruction)
                         (it1p: bool) (k: asm_code -> res asm_code) :=
  match il with
  | nil => k nil
  | i1 :: il' =>
      transl_code_rec f il' (it1_is_parent it1p i1)
        (fun c1 => do c2 <- transl_instr f i1 it1p c1; k c2)
  end.

Definition transl_code' (f: Mach.function) (il: list Mach.instruction) (it1p: bool) :=
  transl_code_rec f il it1p (fun c => OK c).

(** Translation of a whole function.  Note that we must check
  that the generated code contains less than [2^32] instructions,
  otherwise the offset part of the [PC] code pointer could wrap
  around, leading to incorrect executions. *)

Definition transl_function (f: Mach.function) :=
  do c <- transl_code' f f.(Mach.fn_code) true;
  OK (mkfunction f.(Mach.fn_comp) f.(Mach.fn_sig)
        (Pallocframe f.(fn_stacksize) f.(fn_link_ofs) >>
         storeind_ptr RA SP f.(fn_retaddr_ofs) c)).

Definition transf_function (f: Mach.function) : res Asm.function :=
  do tf <- transl_function f;
  if zlt Ptrofs.max_unsigned (list_length_z tf.(fn_code))
  then Error (msg "code size exceeded")
  else OK tf.

Definition transf_fundef (f: Mach.fundef) : res Asm.fundef :=
  transf_partial_fundef transf_function f.

Definition transf_program (p: Mach.program) : res Asm.program :=
  transform_partial_program transf_fundef p.

Lemma transf_function_comp :
  forall f tf, transf_function f = OK tf -> Mach.fn_comp f = fn_comp tf.
Proof.
  intros f tf Htransl.
  unfold transf_function in Htransl.
  apply bind_inversion in Htransl as [f' [Htransl Hsize]].
  destruct (zlt Ptrofs.max_unsigned (list_length_z (fn_code f'))) as [Hlst | Hgeq];
    [now inv Hlst |].
  inv Hsize.
  unfold transl_function in Htransl.
  apply bind_inversion in Htransl as [c [Htransl Hf']].
  inv Hf'.
  reflexivity.
Qed.
